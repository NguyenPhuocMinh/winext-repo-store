'use strict';

const Promise = require('bluebird');
const lodash = require('lodash');
const http = require('http');
const path = require('path');
const express = require('express');
const routerMappings = express.Router();
const app = express();
const logger = require('morgan');
const mongoose = require('mongoose');
const cors = require('cors');
const bodyParser = require('body-parser');
const moment = require('moment');
const momentTimezone = require('moment-timezone');
const slugifyString = require('../config/utils/slugifyString');
const returnCodes = require('../config/utils/returnCodes');
const loggingFactory = require('../config/utils/logger');
const middleware = require('../config/utils/middleware');
const dataMongoose = require('../config/utils/dataMongoose');
const validator = require('../config/utils/validator');
const getRequestId = require('../config/utils/getRequestId');
const { isFunction, isArray, isEmpty, get } = lodash;

function Server() {
  // create server
  const server = http.createServer(app);
  // path api
  const pathServer = "/rest/api"
  // get Promise
  this.Promise = Promise;
  // get Lodash
  this.lodash = lodash;
  // get mongoose
  this.mongoose = mongoose;
  // global Promise
  mongoose.Promise = global.Promise;
  mongoose.set("debug", true);
  // get moment
  this.moment = moment;
  this.momentTimezone = momentTimezone;
  // get slug
  this.slugifyString = slugifyString;
  // get returnCodes
  this.returnCodes = returnCodes;
  // get dataMongoose
  this.dataMongoose = dataMongoose;
  // get validator
  this.validator = validator;
  // get app
  this.app = app;
  // log
  app.use(logger('dev'));
  // connect ui
  app.use(cors());
  app.use(express.static(path.join(__dirname, 'build')));
  app.use('/rest/api/images', express.static('images'));
  const requestId = getRequestId();
  // mapping server
  this.mappingApi = function (mappings) {
    return new Promise((resolve, reject) => {
      app.use(bodyParser.json({ limit: '50mb' }));
      app.use(bodyParser.urlencoded({ limit: '50mb', extended: true }));
      // call api server
      if (!isEmpty(mappings) && isArray(mappings)) {
        mappings.map(mapping => {
          const method = get(mapping, 'method')
          const pathName = get(mapping, 'pathName');
          const serviceName = get(mapping, 'serviceName');
          const methodName = get(mapping, 'methodName');
          const input = get(mapping, 'input') || {};
          const output = get(mapping, 'output') || {};
          const serviceMethod = serviceName[methodName];

          switch (method) {
            case 'GET':
              return app.use(pathServer, routerMappings.get(pathName, (req, res) =>
                middleware(req, res, serviceMethod, input, output)
              ));
            case 'POST':
              return app.use(pathServer, routerMappings.post(pathName, (req, res) =>
                middleware(req, res, serviceMethod, input, output)
              ));
            case 'PUT':
              return app.use(pathServer, routerMappings.put(pathName, (req, res) =>
                middleware(req, res, serviceMethod, input, output)
              ));
            case 'DELETE':
              return app.use(pathServer, routerMappings.delete(pathName, (req, res) =>
                middleware(req, res, serviceMethod, input, output)
              ));
            default:
              return null;
          }
        })
      }
      resolve(app)
    })
      .then(info => {
        return info
      })
      .catch(err => {
        return Promise.reject(err);
      })
  };
  // start server
  this.start = function () {
    const protocolHttp = process.env.PROTOCOL || 'http';
    const portHttp = process.env.PORT || 8080;
    const hostHttp = process.env.HOST || '0.0.0.0';
    return new Promise((resolve, rejects) => {
      const serverInstance = server.listen(portHttp, hostHttp, () => {
        const port = serverInstance.address().port;
        const host = serverInstance.address().address;
        console.info('The server http is running on %s://%s:%s', protocolHttp, host, port);
      })
      resolve(serverInstance)
    })
      .then(info => {
        loggingFactory.warn('Start server', { requestId: `${requestId}` })
        return info
      })
      .catch(err => {
        return Promise.reject(err);
      })
  };
  // stop server
  this.stop = function () {
    return new Promise(function (resolve, reject) {
      const timeOut = setTimeout(function () {
        reject();
      }, 3000);
      loggingFactory.silly("time out", timeOut, { requestId: `${requestId}` });
      const serverClose = function () {
        if (server && isFunction(serverClose)) {
          server.removeListener('close', serverClose)
        }
      }
      loggingFactory.custom('The Server Close');
      server.on('close', serverClose)
      server.close(function (err) {
        clearTimeout(timeOut)
        resolve();
      });
    })
      .then(() => {
        console.info('The Server Has Been Closed');
        process.exit(1);
      })
      .catch(err => {
        loggingFactory.error('error', err);
        return Promise.reject(err)
      })
  };
  // connect database
  this.repository = function (sandbox) {
    const enable = get(sandbox, 'connect.enable');
    const database_local = get(sandbox, 'connect.database_local');
    const database_server = get(sandbox, 'connect.database_server');
    return new Promise((resolve, reject) => {
      let db_url = process.env.DB_URL || database_server;
      if (!enable) {
        db_url = database_local;
      }
      const connect = mongoose.connect(db_url, { useNewUrlParser: true }, (err) => {
        if (!err) {
          console.info(`Connected to the ${db_url}`);
        } else {
          console.info(`Database is not connected`, err);
          reject(err);
        }
      })
      resolve(connect);
    })
      .then(info => {
        return info;
      })
      .catch(err => {
        loggingFactory.error('error', JSON.stringify(err, null, 1));
        return Promise.reject(err)
      })
  };
};

module.exports = new Server();